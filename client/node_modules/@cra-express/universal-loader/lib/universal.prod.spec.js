"use strict";

var _react = _interopRequireDefault(require("react"));

var _universal = _interopRequireDefault(require("./universal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

process.env.NODE_ENV = 'production';
jest.mock('fs');

var fs = require('fs');

test('have correct env', function () {
  expect(process.env.NODE_ENV).toBe('production');
});
test('created correctly', function () {
  var config = {
    handleRender: jest.fn(),
    clientBuildPath: 'test',
    universalRender: function universalRender() {
      return _react.default.createElement("div", null, "a");
    }
  };
  var middleware = (0, _universal.default)(config);
  expect(middleware).toBeDefined();
});
test('read index.html file correctly', function () {
  var config = {
    handleRender: jest.fn(),
    clientBuildPath: 'test',
    universalRender: function universalRender() {
      return _react.default.createElement("div", null, "a");
    }
  };
  var middleware = (0, _universal.default)(config);
  middleware();
  expect(fs.readFile).toHaveBeenCalledTimes(1);
});
test('handle read error correctly', function () {
  var config = {
    handleRender: jest.fn(),
    clientBuildPath: 'test',
    universalRender: function universalRender() {
      return _react.default.createElement("div", null, "a");
    }
  };
  var middleware = (0, _universal.default)(config);
  jest.spyOn(fs, 'readFile').mockImplementation(function (filepath, enc, callback) {
    var err = {
      message: 'mock readFile error'
    };
    var htmlData = null;
    callback(err, htmlData);
  });
  var spy = jest.spyOn(console, 'error');
  var mockStatus = {
    end: jest.fn()
  };
  var mockResponse = {
    status: jest.fn(function () {
      return mockStatus;
    })
  };
  middleware({}, mockResponse);
  expect(mockResponse.status).toHaveBeenCalledWith(404);
  expect(console.error).toHaveBeenCalledTimes(1);
  spy.mockReset();
  spy.mockRestore();
});
test('send response successfully', function () {
  var config = {
    clientBuildPath: 'test',
    handleRender: jest.fn(),
    universalRender: function universalRender() {
      return _react.default.createElement("div", null, "a");
    }
  };
  var middleware = (0, _universal.default)(config);
  jest.spyOn(fs, 'readFile').mockImplementation(function (filepath, enc, callback) {
    var htmlData = '<html><div id="root"></div></html>';
    callback(null, htmlData);
  });
  var spy = jest.spyOn(console, 'error');
  var mockResponse = {
    write: jest.fn(),
    end: jest.fn()
  };
  middleware({}, mockResponse);
  expect(console.error).toHaveBeenCalledTimes(0);
  expect(config.handleRender).toHaveBeenCalledTimes(1);
  spy.mockReset();
  spy.mockRestore();
});
test('send response successfully with onEndReplace callback', function () {
  var config = {
    clientBuildPath: 'test',
    handleRender: function handleRender(req, res, reactEl, htmlData, options) {
      options.onEndReplace('replace');
    },
    onEndReplace: jest.fn(function (html) {
      return html;
    }),
    universalRender: function universalRender() {
      return _react.default.createElement("div", null, "a");
    }
  };
  var middleware = (0, _universal.default)(config);
  jest.spyOn(fs, 'readFile').mockImplementation(function (filepath, enc, callback) {
    var htmlData = '<html><div id="root"></div></html>';
    callback(null, htmlData);
  });
  var spy = jest.spyOn(console, 'error');
  var mockResponse = {
    write: jest.fn(),
    end: jest.fn()
  };
  middleware({}, mockResponse);
  expect(console.error).toHaveBeenCalledTimes(0);
  expect(config.onEndReplace).toHaveBeenCalledWith('replace');
  spy.mockReset();
  spy.mockRestore();
});
test('send response successfully and close tag correctly', function () {
  var config = {
    clientBuildPath: 'test',
    handleRender: jest.fn(),
    universalRender: function universalRender() {
      return _react.default.createElement("div", null, "a");
    }
  };
  var middleware = (0, _universal.default)(config);
  jest.spyOn(fs, 'readFile').mockImplementation(function (filepath, enc, callback) {
    var htmlData = '<html><div id="root"></div><div id="test">should be included</div></html>';
    callback(null, htmlData);
  });
  var spy = jest.spyOn(console, 'error');
  var mockResponse = {
    write: jest.fn(),
    end: jest.fn()
  };
  middleware({}, mockResponse);
  expect(console.error).toHaveBeenCalledTimes(0);
  expect(config.handleRender).toHaveBeenCalledTimes(1);
  spy.mockReset();
  spy.mockRestore();
});
test('support async universal render callback', function () {
  var mockResponse = {
    write: jest.fn(),
    end: jest.fn()
  };
  var mockStream = {
    on: jest.fn(function (type, callback) {
      if (type == 'end') {
        callback();
        expect(mockResponse.write).toHaveBeenCalledTimes(2);
        expect(mockResponse.end).toHaveBeenCalledTimes(1);
        expect(mockResponse.write.mock.calls[0]).toEqual(['<html><div id="root">']);
        expect(mockResponse.write.mock.calls[1]).toEqual(['</div></html>']);
      }
    }),
    pipe: jest.fn()
  };
  var config = {
    clientBuildPath: 'test',
    handleRender: jest.fn(),
    universalRender: function universalRender() {
      return Promise.resolve(_react.default.createElement("div", null, "a"));
    }
  };
  var middleware = (0, _universal.default)(config);
  jest.spyOn(fs, 'readFile').mockImplementation(function (filepath, enc, callback) {
    var htmlData = '<html><div id="root"></div></html>';
    callback(null, htmlData);
  });
  var spy = jest.spyOn(console, 'error');
  middleware({}, mockResponse);
  expect(console.error).toHaveBeenCalledTimes(0);
  spy.mockReset();
  spy.mockRestore();
});
test('handle undefined and not sending response', function () {
  var config = {
    clientBuildPath: 'test',
    handleRender: jest.fn(),
    universalRender: function universalRender() {
      return undefined;
    }
  };
  var middleware = (0, _universal.default)(config);
  jest.spyOn(fs, 'readFile').mockImplementation(function (filepath, enc, callback) {
    var htmlData = '<html><div id="root"></div></html>';
    callback(null, htmlData);
  });
  var spy = jest.spyOn(console, 'error');
  var mockResponse = {
    write: jest.fn(),
    end: jest.fn()
  };
  middleware({}, mockResponse);
  expect(mockResponse.write).not.toHaveBeenCalled();
  expect(mockResponse.end).not.toHaveBeenCalled();
  expect(console.error).toHaveBeenCalledTimes(0);
  spy.mockReset();
  spy.mockRestore();
});
test('handle undefined and not sending response for async', function () {
  var config = {
    clientBuildPath: 'test',
    handleRender: jest.fn(),
    universalRender: function universalRender() {
      return Promise.resolve(undefined);
    }
  };
  var middleware = (0, _universal.default)(config);
  jest.spyOn(fs, 'readFile').mockImplementation(function (filepath, enc, callback) {
    var htmlData = '<html><div id="root"></div></html>';
    callback(null, htmlData);
  });
  var spy = jest.spyOn(console, 'error');
  var mockResponse = {
    write: jest.fn(),
    end: jest.fn()
  };
  middleware({}, mockResponse);
  expect(mockResponse.write).not.toHaveBeenCalled();
  expect(mockResponse.end).not.toHaveBeenCalled();
  expect(console.error).toHaveBeenCalledTimes(0);
  spy.mockReset();
  spy.mockRestore();
});